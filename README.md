## アップグレードψ関数 to BMS

### 準備
- `0`と`+`と`Ω`と`ψ`と`(`と`,`と`)`のみからなる'''1文字以上'''の文字列の集合をΓとする。
- 集合Sに対し、Array[S]で∪_{k=0^∞}S^kを表すことにする。Sの無限列は含まないものとする。
- 文字列の配列Tに対し、ΣTでTの要素を連結させたものを表す。
- 配列Aの長さをA.lengthで表す。

### トークン化
t∈RTに対し、tの'''トークン化'''tokenize(t)=A∈Array[Γ]を以下を満たす唯一の配列として定義する。

- ΣA=t
- Aは以下の形の文字列である:
  - "0"
  - "+"
  - ")"
  - Σ["Ω(", $n, ","] ただしn∈N+
  - "ψ(0,"
  - Σ["ψ(Ω(", ${n}, ",0),"] ただしn∈Nかつn>=1

### 冗長化
A∈Array[Γ]に対し、Aの'''冗長化'''decompress(A)=B∈Array[Γ]を以下で定義する。

'''わんだほい:''' ここが一番難しいプロセスである。

### 上昇化
A∈Array[Γ]に対し、Aの'''上昇化'''enraise(A)=C∈Array[Γ]を以下で定義する。

- i=0とする。
- B=[]とする。
- stack=[]とする。
- i<A.lengthである間、以下を実行する:
　　- もしA[i]="0"またはA[i]="+"ならば、何もしない。
  - もしA[i]=")"ならば、
    - Bに")"を追加する。
    - stackの最後の要素を削除する。
  - もしA[i]="ψ(0,"なら、
    - Bに"ψ(0,"を追加する。
    - stackに"ψ(0,"を追加する。
  - もしA[i]=Σ["ψ(Ω(", $n, ",0),"]と書けるn∈Nがあるなら、
    - BにΣ["ψ(", $n, ","]を追加する。
    - stackにΣ["ψ(Ω(", $n, ",0),"]を追加する。
  - もしA[i]=Σ["Ω(", $n, ","]と書けるn∈Nがあるなら、
    - stackの右から順に、Σ["ψ(Ω(", $m, ",0),"] (m∈N)または"ψ(0,"の形に書ける要素を探し、それをbとする。
    - BにΣ["ψ(",$(m+n), ","]を追加する。
    - stackにΣ["Ω(", $n, ","]を追加する。
  - もしA[i]=Σ["Ω(", $ω, ","]なら、
    - BにΣ["Ω(", $ω, ","]を追加する。
    - stackにΣ["Ω(", $ω, ","]を追加する。
  - iに1を足す。
- C=Bとする。

### BMS化
A∈Array[Γ]に対し、Aの'''BMS化'''to_BMS(A)=C∈BMSを以下で定義する。

- i=0とする。
- B=とする。
- stack=[]とする。
- i<A.lengthである間、以下を実行する:
  - 現在のstackの長さをtとする。
　　- もしA[i]="0"またはA[i]="+"ならば、何もしない。
  - もしA[i]=")"ならば、
    - stackの最後の要素を削除する。
  - もしA[i]="ψ(0,"なら、
    - Aに(t,0,0)を追加する。
    - stackに"ψ(0,"を追加する。
  - もしA[i]=Σ["ψ(Ω(", $n, ",0),"]と書けるn∈Nがあるなら、
    - Aに(t,n,0)を追加する。
    - stackにΣ["ψ(Ω(", $n, ",0),"]を追加する。
  - もしA[i]=Σ["Ω(", $n, ","]、ただし#{ω}=$ωなら、
    - Aに(t,1,1)を追加する。
    - stackにΣ["Ω(", $n, ","]を追加する。
  - iに1を足す。
- C=Bとする。


## 今後の課題
展開規則がBMSと一致するかを調べる。


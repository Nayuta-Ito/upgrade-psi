## アップグレードψ関数 to BMS

### 準備
- `0`と`+`と`Ω`と`ψ`と`(`と`,`と`)`のみからなる'''1文字以上'''の文字列の集合をΓとする。
- 集合Sに対し、Array[S]で∪_{k=0^∞}S^kを表すことにする。Sの無限列は含まないものとする。
- 文字列の配列Tに対し、ΣTでTの要素を連結させたものを表す。
- 配列Aの長さをA.lengthで表す。
- 配列に対する`[]`および`+`の用法はRuby 3.3.0に従うものとする。

### トークン化
t∈RTに対し、tの'''トークン化'''tokenize(t)=A∈Array[Γ]を以下を満たす唯一の配列として定義する。

- ΣA=t
- Aは以下の形の文字列である:
  - "0"
  - "+"
  - ")"
  - Σ["Ω(", $n, ","] ただしn∈N+
  - "ψ(0,"
  - Σ["ψ(Ω(", ${n}, ",0),"] ただしn∈Nかつn>=1

### 冗長化
A∈Array[Γ]に対し、Aの'''冗長化'''decompress(A)=C∈Array[Γ]を以下で定義する。

- i=0とする。
- B=[]とする。
- A'をAのコピーとする。A'は走査中に書き換えるかもしれない。
- stack=[]とする。
- i<A'.lengthである間、以下を実行する:
　　- もしA'[i]="0"またはA'[i]="+"ならば、何もしない。
  - もしA'[i]=")"ならば、
    - Bに")"を追加する。
    - stackの最後の要素を削除する。
  - もしA'[i]="ψ(0,"なら、
    - Bに"ψ(0,"を追加する。
    - stackに"ψ(0,"を追加する。
  - もしA'[i]=Σ["ψ(Ω(", $n, ",0),"]と書けるn∈Nがあるなら、
    - A'[i]の最初の`(`に対応する`)`の位置をA'[j]とする。
    - D=Σ(A'[0...i]+["0"]+A'[(j+1)..-1])とする。
    - D'=D[1]とする。
    - E=tokenize(D')とする。
    - E[i]の最初の`(`に対応する`)`の位置をE[j']とする。
    - j''=j'-3とする。 # E[j'']はψで始まる
    - A'を、Σ(A'[0...i]+E[i...j'']+A'[i..j]+E[j'..-1])に置き換える。
    - iから1を引く。
  - もしA'[i]=Σ["Ω(", $ω, ","]なら、
    - BにΣ["Ω(", $ω, ","]を追加する。
    - stackにΣ["Ω(", $ω, ","]を追加する。
  - iに1を足す。
- C=Bとする。

### 上昇化
A∈Array[Γ]に対し、Aの'''上昇化'''enraise(A)=C∈Array[Γ]を以下で定義する。

- i=0とする。
- B=[]とする。
- stack=[]とする。
- i<A.lengthである間、以下を実行する:
　　- もしA[i]="0"またはA[i]="+"ならば、何もしない。
  - もしA[i]=")"ならば、
    - Bに")"を追加する。
    - stackの最後の要素を削除する。
  - もしA[i]="ψ(0,"なら、
    - Bに"ψ(0,"を追加する。
    - stackに"ψ(0,"を追加する。
  - もしA[i]=Σ["ψ(Ω(", $n, ",0),"]と書けるn∈Nがあるなら、
    - BにΣ["ψ(", $n, ","]を追加する。
    - stackにΣ["ψ(Ω(", $n, ",0),"]を追加する。
  - もしA[i]=Σ["Ω(", $n, ","]と書けるn∈Nがあるなら、
    - stackの右から順に、Σ["ψ(Ω(", $m, ",0),"] (m∈N)または"ψ(0,"の形に書ける要素を探し、それをbとする。
    - BにΣ["ψ(",$(m+n), ","]を追加する。
    - stackにΣ["Ω(", $n, ","]を追加する。
  - もしA[i]=Σ["Ω(", $ω, ","]なら、
    - BにΣ["Ω(", $ω, ","]を追加する。
    - stackにΣ["Ω(", $ω, ","]を追加する。
  - iに1を足す。
- C=Bとする。

### BMS化
A∈Array[Γ]に対し、Aの'''BMS化'''to_BMS(A)=C∈BMSを以下で定義する。

- i=0とする。
- B=とする。
- stack=[]とする。
- i<A.lengthである間、以下を実行する:
  - 現在のstackの長さをtとする。
　　- もしA[i]="0"またはA[i]="+"ならば、何もしない。
  - もしA[i]=")"ならば、
    - stackの最後の要素を削除する。
  - もしA[i]="ψ(0,"なら、
    - Aに(t,0,0)を追加する。
    - stackに"ψ(0,"を追加する。
  - もしA[i]=Σ["ψ(Ω(", $n, ",0),"]と書けるn∈Nがあるなら、
    - Aに(t,n,0)を追加する。
    - stackにΣ["ψ(Ω(", $n, ",0),"]を追加する。
  - もしA[i]=Σ["Ω(", $ω, ","]なら、
    - stackの中で、n∈Nに対しΣ["ψ(Ω(", $n, ",0),"]と書けるものの中で最も右にあるものに対応するnをuとする。
    - Aに(t,u,1)を追加する。
    - stackにΣ["Ω(", $n, ","]を追加する。
  - iに1を足す。
- C=Bとする。


## 今後の課題
展開規則がBMSと一致するかを調べる。

